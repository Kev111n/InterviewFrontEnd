## 防抖

```javascript
function debounce(fn, wait) {
  let timer = null;
  return function() {
    if(timer) {
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, wait);
  }
}
```

## 节流

```javascript
function throttle(fn, delay) {
  let timer = null;
  return function () {
    if (timer) return;
    timer = setTimeout(() => {
      timer = null;
      return fn.apply(this, arguments);
    }, delay)
  }
}
```

## 深拷贝与浅拷贝

**浅拷贝**指的是只复制对象或数组本身，而不复制它们内部引用的其他对象或数组。也就是说，浅拷贝会创建一个新的对象或数组，并将原始对象或数组中的元素复制到新的对象或数组中，但是这些元素仍然是原始对象或数组中元素的引用。

**深拷贝（Deep Copy）**是创建一个新的对象，该对象与原始对象完全独立，在内存中占据不同的位置。深拷贝会复制原始对象的所有属性和嵌套对象，并且对其中一个对象的修改不会影响到另一个对象。

#### 浅拷贝

##### 1.Object.create(obj)

```javascript
let obj1 = {
 name: '小明'
}
let obj2 = Object.create(obj1)
obj1.name = '小红'

console.log(obj1.name); // 输出 '小红'

```

##### 2.Object.assign({} , obj)

Object.assign({} ，obj) 方法会将所有可枚举的自有属性从一个或多个源对象复制到目标对象，并返回目标对象。该方法执行的是浅拷贝，因此如果源对象的属性值是基本类型数据，那么它们会被复制到目标对象中，这种数据类似深拷贝，改动目标对象不会印象原对象，如果是引用类型数据，则仅复制它们的引用，这种数据改动目标对象也会修改原对象中的值。

```javascript
    let obj = {
    name: '小明',
    like: {
        n: 'coding'
    }
}
let obj2 = Object.assign({}, obj );
obj.name = '小红' ;
obj.like.n = 'running' ;
console.log(obj); 
/**结果为：
*{
*name:'小明',
*like:{
*	n:'running'，
*}
*}*/
}
```

##### 3.[ ].concat(arr)

类似Object.assign({},obj)只有引用类型数据的修改才会同时影响

```javascript
let arr = [1,2,3,{n:10}]
let newArr = [].concat(arr)
arr.push(4)
arr[3].n = 100
arr[2]=1000
console.log(newArr);
//[1,2,3,{n:100}]
```

##### 4.数组解构

同上

```javascript
    let arr = [1,2,3,{n:10}]
    arr.push(4)
    let newArr = [...arr]
    arr[3].n = 100
    arr[2]=1000
    console.log(newArr);
	//[1,2,3,{n:100}]
```

#### 深拷贝

##### 方法一

```javascript
    let obj = {
    name: '李总',
    age: 18,
    a: {
        n: 1
    },
    b: undefined, 
    c: null,
    d: function() {},
    e: Symbol('hello'),
    f: {
        n: 100
    }
}
function deepCopy(obj) {
    let objCopy = {} // 创建一个空对象，用于存放拷贝后的对象
    for (let key in obj) { // 遍历对象的所有属性
    if (obj.hasOwnProperty(key)) { // 使用hasOwnProperty方法确保只拷贝对象自身的属性
     if (obj[key] instanceof Object) { // 判断属性值是否为引用类型
       objCopy[key] = deepCopy(obj[key]);        
     } else {
       objCopy[key] = obj[key] // 如果是原始类型，则直接赋值
     }
    }
 }
    return objCopy
}
let obj2 = deepCopy(obj);
console.log(obj2);

```

##### 方法二：JSON.parse(JSON.stringify(obj))

```javascript
    let obj = {
    name: '李总',
    age: 18,
    a: {
        n: 1
    },
    b: undefined, 
    c: null,
    d: function() {},
    e: Symbol('hello'),
    f: {
        n: 100
    }
}
console.log(obj);
console.log(JSON.stringify(obj));// 把对象变成字符串
console.log(JSON.parse(str)); // 把字符串变成对象
newObj=JSON.parse(JSON.stringify(obj))//深拷贝
```

## 手写快排

```typescript
function quickSort(arr: number[], low: number, high: number): void {
  if (low < high) {
    // 获取分区索引
    const partitionIndex = partition(arr, low, high);

    // 递归调用
    quickSort(arr, low, partitionIndex - 1);
    quickSort(arr, partitionIndex + 1, high);
  }
}

function partition(arr: number[], low: number, high: number): number {
  // 选择基准值
  const pivot = arr[high];

  // 初始化分区索引
  let i = low - 1;

  // 将小于等于基准值的元素放到基准值的左侧
  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 交换基准值和分区索引+1位置的元素
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];

  // 返回分区索引+1作为新的基准值索引
  return i + 1;
}

// 测试用例
const arr = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];
quickSort(arr, 0, arr.length - 1);
console.log(arr);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]
```

## 使用setTimeout实现setInterval

```javascript
function customSetInterval(callback,delay){
    let timer;
    function interval(callback,delay){
        callback();
        timer=setTimeout(interval,delay);
    }
    timer=setTimeout(interval,delay);
    return ()=>{
        clearTimeout(timer);
    }
} 
```

## 查看树中某节点的所有子节点

![](./images/treeQuestion1.jpeg)
实现fn
```javascript
function fn(tree, targetId, key = "id") {
  let result = [];
  function pushChildren(node) {
    if (node.children) {
      for (const child of node.children) {
        result.push(child[key]);
        if (child.children) {
          pushChildren(child);
        }
      }
    }
  }
  function traverse(nodes) {
    for (const node of nodes) {
      if (node[key] === targetId) {
        if (node.children) {
          pushChildren(node);
        }
      } else if (node.children) {
        traverse(node.children); // 继续遍历其他节点的子节点
      }
    }
  }

  traverse(tree);
  return result;
}
```

## 请编写一个名为 executeTasks 的函数。这个函数需要接受一个异步任务数组作为参数。每个任务是一个会返回 Promise 的函数。你的目标是同时启动这些异步任务，并且在每个任务完成时，立即按照它们在数组中的原始顺序显示它们的结果。

```javascript
function executeTasks(tasks) {  
    // 创建一个与任务数量相同的数组来保存结果  
    const results = new Array(tasks.length);  
  
    // 创建一个计数器来跟踪已完成的 Promise 数量  
    let completedCount = 0;  
  
    // 遍历任务数组，为每个任务创建一个 Promise 并添加到 Promise 数组中  
    const promises = tasks.map((task, index) => {  
        return task().then(result => {  
            // 当 Promise 完成时，将结果放入结果数组的正确位置  
            results[index] = result;  
            // 打印结果（或进行其他处理）  
            console.log(`Task ${index + 1} completed with result:`, result);  
            // 增加已完成的 Promise 计数  
            completedCount++;  
  
            // 如果所有 Promise 都已完成，我们可以选择做一些清理工作或返回结果数组  
            if (completedCount === tasks.length) {  
                // 例如，我们可以选择在这里返回结果数组  
                // return results; // 如果需要，可以取消注释这行代码  
            }  
        });  
    });  
  
    // 启动所有 Promise  
    // 注意：我们不使用 Promise.all，因为我们希望在每个 Promise 完成时立即处理结果  
    // 但如果你需要等待所有 Promise 完成后再进行某些操作，你可以使用 Promise.all(promises).then(...)  
}  
  
// 示例用法：  
const asyncTask1 = () => new Promise(resolve => setTimeout(() => resolve('Task 1 result'), 1000));  
const asyncTask2 = () => new Promise(resolve => setTimeout(() => resolve('Task 2 result'), 500));  
const asyncTask3 = () => new Promise(resolve => setTimeout(() => resolve('Task 3 result'), 750));  
  
executeTasks([asyncTask1, asyncTask2, asyncTask3]);
```

## 编写一个 JavaScript 函数，该函数能够将给定的虚拟 DOM 对象（JSON格式）转换为真实的 DOM 结构，并将其插入到页面中。

```javascript
function createElementFromVirtualDOM(virtualNode) {  
    // 创建一个真实的 DOM 元素  
    const element = document.createElement(virtualNode.type);  
  
    // 遍历属性并添加到元素上  
    if (virtualNode.props) {  
        for (let propName in virtualNode.props) {  
            if (propName === 'children') continue; // 'children' 是子节点的特殊属性，稍后处理  
            if (propName.startsWith('on')) {  
                // 假设属性以 'on' 开头的是事件监听器  
                element.addEventListener(propName.toLowerCase().substring(2), virtualNode.props[propName]);  
            } else {  
                // 其他属性直接设置  
                element.setAttribute(propName, virtualNode.props[propName]);  
            }  
        }  
    }  
  
    // 递归处理子节点  
    if (virtualNode.children) {  
        virtualNode.children.forEach(child => {  
            // 假设 children 是数组，每个元素都是另一个虚拟 DOM 节点  
            const realChild = createElementFromVirtualDOM(child);  
            // 将子元素添加到当前元素中  
            element.appendChild(realChild);  
        });  
    }  
  
    // 返回创建的 DOM 元素  
    return element;  
}  
  
// 使用示例  
const virtualDOM = {  
    type: 'div',  
    props: {  
        id: 'myDiv',  
        className: 'myClass',  
        onClick: function() { console.log('Div clicked!'); }  
    },  
    children: [  
        {  
            type: 'p',  
            props: {},  
            children: ['Hello, World!']  
        },  
        {  
            type: 'button',  
            props: {  
                onClick: function() { console.log('Button clicked!'); }  
            },  
            children: ['Click Me']  
        }  
    ]  
};  
  
// 将虚拟 DOM 转换为真实 DOM 并插入到 body 中  
const realDOM = createElementFromVirtualDOM(virtualDOM);  
document.body.appendChild(realDOM);
```

