## 防抖

```javascript
function debounce(fn, wait) {
  let timer = null;
  return function() {
    if(timer) {
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, wait);
  }
}
```

## 节流

```javascript
function throttle(fn, delay) {
  let timer = null;
  return function () {
    if (timer) return;
    timer = setTimeout(() => {
      timer = null;
      return fn.apply(this, arguments);
    }, delay)
  }
}
```

## 深拷贝与浅拷贝

**浅拷贝**指的是只复制对象或数组本身，而不复制它们内部引用的其他对象或数组。也就是说，浅拷贝会创建一个新的对象或数组，并将原始对象或数组中的元素复制到新的对象或数组中，但是这些元素仍然是原始对象或数组中元素的引用。

**深拷贝（Deep Copy）**是创建一个新的对象，该对象与原始对象完全独立，在内存中占据不同的位置。深拷贝会复制原始对象的所有属性和嵌套对象，并且对其中一个对象的修改不会影响到另一个对象。

#### 浅拷贝

##### 1.Object.create(obj)

```javascript
let obj1 = {
 name: '小明'
}
let obj2 = Object.create(obj1)
obj1.name = '小红'

console.log(obj1.name); // 输出 '小红'

```

##### 2.Object.assign({} , obj)

Object.assign({} ，obj) 方法会将所有可枚举的自有属性从一个或多个源对象复制到目标对象，并返回目标对象。该方法执行的是浅拷贝，因此如果源对象的属性值是基本类型数据，那么它们会被复制到目标对象中，这种数据类似深拷贝，改动目标对象不会印象原对象，如果是引用类型数据，则仅复制它们的引用，这种数据改动目标对象也会修改原对象中的值。

```javascript
    let obj = {
    name: '小明',
    like: {
        n: 'coding'
    }
}
let obj2 = Object.assign({}, obj );
obj.name = '小红' ;
obj.like.n = 'running' ;
console.log(obj); 
/**结果为：
*{
*name:'小明',
*like:{
*	n:'running'，
*}
*}*/
}
```

##### 3.[ ].concat(arr)

类似Object.assign({},obj)只有引用类型数据的修改才会同时影响

```javascript
let arr = [1,2,3,{n:10}]
let newArr = [].concat(arr)
arr.push(4)
arr[3].n = 100
arr[2]=1000
console.log(newArr);
//[1,2,3,{n:100}]
```

##### 4.数组解构

同上

```javascript
    let arr = [1,2,3,{n:10}]
    arr.push(4)
    let newArr = [...arr]
    arr[3].n = 100
    arr[2]=1000
    console.log(newArr);
	//[1,2,3,{n:100}]
```

#### 深拷贝

##### 方法一

```javascript
    let obj = {
    name: '李总',
    age: 18,
    a: {
        n: 1
    },
    b: undefined, 
    c: null,
    d: function() {},
    e: Symbol('hello'),
    f: {
        n: 100
    }
}
function deepCopy(obj) {
    let objCopy = {} // 创建一个空对象，用于存放拷贝后的对象
    for (let key in obj) { // 遍历对象的所有属性
    if (obj.hasOwnProperty(key)) { // 使用hasOwnProperty方法确保只拷贝对象自身的属性
     if (obj[key] instanceof Object) { // 判断属性值是否为引用类型
       objCopy[key] = deepCopy(obj[key]);        
     } else {
       objCopy[key] = obj[key] // 如果是原始类型，则直接赋值
     }
    }
 }
    return objCopy
}
let obj2 = deepCopy(obj);
console.log(obj2);

```

##### 方法二：JSON.parse(JSON.stringify(obj))

```javascript
    let obj = {
    name: '李总',
    age: 18,
    a: {
        n: 1
    },
    b: undefined, 
    c: null,
    d: function() {},
    e: Symbol('hello'),
    f: {
        n: 100
    }
}
console.log(obj);
console.log(JSON.stringify(obj));// 把对象变成字符串
console.log(JSON.parse(str)); // 把字符串变成对象
newObj=JSON.parse(JSON.stringify(obj))//深拷贝
```

## 手写快排

```typescript
function quickSort(arr: number[], low: number, high: number): void {
  if (low < high) {
    // 获取分区索引
    const partitionIndex = partition(arr, low, high);

    // 递归调用
    quickSort(arr, low, partitionIndex - 1);
    quickSort(arr, partitionIndex + 1, high);
  }
}

function partition(arr: number[], low: number, high: number): number {
  // 选择基准值
  const pivot = arr[high];

  // 初始化分区索引
  let i = low - 1;

  // 将小于等于基准值的元素放到基准值的左侧
  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 交换基准值和分区索引+1位置的元素
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];

  // 返回分区索引+1作为新的基准值索引
  return i + 1;
}

// 测试用例
const arr = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];
quickSort(arr, 0, arr.length - 1);
console.log(arr);  // 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]
```

## 使用setTimeout实现setInterval

```javascript
function customSetInterval(callback,delay){
    let timer;
    function interval(callback,delay){
        callback();
        timer=setTimeout(interval,delay);
    }
    timer=setTimeout(interval,delay);
    return ()=>{
        clearTimeout(timer);
    }
} 
```

## 查看树中某节点的所有子节点

![](.\images\treeQuestion1.jpeg)

```javascript
function fn(tree, targetId, key = "id") {
  let result = [];
  function pushChildren(node) {
    if (node.children) {
      for (const child of node.children) {
        result.push(child[key]);
        if (child.children) {
          pushChildren(child);
        }
      }
    }
  }
  function traverse(nodes) {
    for (const node of nodes) {
      if (node[key] === targetId) {
        if (node.children) {
          pushChildren(node);
        }
      } else if (node.children) {
        traverse(node.children); // 继续遍历其他节点的子节点
      }
    }
  }

  traverse(tree);
  return result;
}
```

### 